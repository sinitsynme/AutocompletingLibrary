# AutocompletingLibrary (Библиотека автодополнения)

Простой движок автодополнения, основанный на боре (префиксном дереве)


[RUS](README_ru.md) | [ENG](README.md)
-------

В проект встроен тестовый CSV-файл (airports.csv). Цель приложения следующая: вы фиксируете колонку, по которой ведётся "поиск", вводите в консоль предполагаемое начало искомых значений (префикс). Движок ищет колонки, начинающиеся с префикса, и выдаёт исходные строки - результаты поиска.

Номер колонки фиксируется при запуске приложения (в тестовом файле вы можете фиксировать с 1 по 14 колонку). 

## Руководство по запуску приложения

1. Клонируйте проект или скачайте ZIP, используя GitHub
2. Запустите терминал
3. Перейдите в директорию проекта ("AutocompletingLibrary-master"), при желании переименуйте её
4. Запустите команду "mvn clean package", чтобы собрать архив .jar

![image](https://user-images.githubusercontent.com/72615475/185341545-aca2ff1b-4118-476a-a010-0800b7f91b27.png)

5. Перейдите в директорию "target" (относительно директории проекта)

![image](https://user-images.githubusercontent.com/72615475/185341732-d7b5aebc-5e8b-41f7-8db9-fe6282182fcd.png)

6. Запустите приложение, введя команду "java -jar airports-search-*.jar" и добавьте корректный номер колонки, в которой будет проходить поиск. Иначе приложение выдаст ошибку.

![image](https://user-images.githubusercontent.com/72615475/185341936-b98fa1ee-cb6a-4e7f-833a-1ff42f9943ba.png)

7. Введите в терминал префикс (поисковый запрос), например, "Bo" (латиница), и нажмите ENTER.

Вы получите результаты в следующей форме: <значение колонки>[<вся строка из файла>]. После на экране появится число результатов и время поиска в миллисекундах (ms). 

![image](https://user-images.githubusercontent.com/72615475/185342645-0267e025-996a-4956-81aa-036158f0bbbc.png)

Обратите внимание на то, что приложение не допускает пустые поисковые запросы (пустые строки или пробелы без других символов), однако trailing spaces (начальные и конечные пробелы) и регистр не важны. 

![image](https://user-images.githubusercontent.com/72615475/185343490-d7f8d58e-2c46-4049-903d-2b978f35b44c.png)

8. Дальше введите "!quit" и нажмите ENTER, чтобы завершить работу приложения, или просто нажмите ENTER, чтобы начать поиск заново (шаг 7).

![image](https://user-images.githubusercontent.com/72615475/185348124-767b6f6d-ef9a-463e-84d1-5094a6d6f48a.png)

## Идея, на которой основан движок

Для обеспечения эффективности по времени за основу движка было взято префиксное дерево (или бор). 

Префиксное дерево - это структура данных, граф, содержащий в себе вершины с символами. Любой путь от корня до листа в боре - это завершённая фраза. Поиск строк по префиксу в таком дереве осуществляется за O(n), где n - длина образца строки (не количество строк в файле), что позволяет быстро искать строки.

Ещё одна интерпретация префиксного дерева - детерменированный конечный автомат (автомат, принимающий или отклоняющий строку путем прохождения через последовательность состояний). 

![image](https://user-images.githubusercontent.com/72615475/185588397-5ce9bf63-b518-4119-a12e-adaaf829dbb8.png)


В самом начале работы приложения обрабатывается файл табличного вида (например, CSV) в зависимости от парсера. Значения определённой колонки, одно за другим, добавляется в префиксное дерево движком. Каждое значение в дереве заканчивается листом с терминальным символом **$**, и в этом листе лежит ID значения (номер строки в файле), по которому будет восстанавливаться исходная строка файла. 

После отправки префикса дереву вернётся список из ID всех фраз, удовлетворяющих префиксу. Значения колонки будут отфильтрованы, результаты отсортированы и отформатированы в соответствии с заданием, и отправлены из движка автодополнения списком из строк.

**Временные ограничения и ограничения по памяти**: запросы любого вида работают быстро (в среднем 20-50 ms, как короткий, так и длинный), однако требование по памяти выполнено не было. Приложение на второй колонке "падает" при памяти, меньшей чем 15 МБ, а начинает работать быстрее с 20 МБ. Остальные колонки могут быть запущены и с 7 MB.

Причина этого следующая: вторая колонка содержит длинные и очень сильно различающиеся строки (названия аэропортов), поэтому дерево становится похожим на "иву" (в боре уже на небольшой глубине у большинства узлов оказывается только по одному дочернему - больше разветвлений нет, и длина таких "цепочек" внушительная - на них выделяется много лишней памяти). Решение этому - сжатие таких цепочек до узлов со строками, однако как это реализовать, я пока не придумал.


## Спорные моменты по функциональным требованиям, не описанные в техзадании, и предлагаемое их решение

1) "Пустые" запросы

Принято решение не допускать запросы, состоящие только из пробелов или являющиеся пустой строкой. Этого не допускают поисковые системы типа Google или Yandex. 

Однако если задан запрос " Kurumoch Int ", то движок уберёт все trailing spaces и регистр, и запрос станет "kurumoch int". Программа отработает корректно. 

2) Лексикографический и числовой порядок

Проблема сортировки результатов в числовом порядке решена следующим образом: сначала на экран выводятся меньшие числа, а затем большие, причём знак числа имеет значение. (-80 будет раньше чем -8, потому что это числовой порядок). При этом не важно, число целое или с плавающей точкой.

![image](https://user-images.githubusercontent.com/72615475/185349157-950f1194-53c9-4ede-9aa1-f89d12447cc8.png)

Строковые значения выводим в обычном лексикографическом порядке.

3) NULL-значения в файле

Возник вопрос - что делать с такими значениями. Иногда в файле встречалась последовательность символов **\N**, я почти уверен, что это undefined (понятно из контекста, так как в числовых колонках попадается строковое значение без кавычек). Ничто другое это обозначать не может.

![image](https://user-images.githubusercontent.com/72615475/185350773-a39ece5c-9a19-4b8c-ae0a-5e84b9693946.png)

Было принято следующее решение: если у какой-то строки в зафиксированной пользователем колонке встречается значение **\N**, то эта строка игнорируется и не участвует в поиске. Это достаточно логично - мы не можем найти то, чего нет. Строки с иными значениями в этой колонке могут быть найдены с помощью запросов.





